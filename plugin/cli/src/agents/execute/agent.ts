/**
 * Execute Agent
 *
 * Executes plans generated by Claude Code's plan mode via the /harness skill.
 * Unlike other agents, this one skips the initializer phase - tasks come from
 * the pre-generated execution config.
 *
 * Key differences from other agents:
 * - No initializer phase (tasks are pre-defined in config)
 * - Bounded summary system (last 3 summaries + stats in prompt)
 * - Full plan context in every worker prompt
 */

import { readFileSync, existsSync, mkdirSync } from "node:fs";
import { resolve, dirname } from "node:path";
import { fileURLToPath } from "node:url";
import { spawn } from "node:child_process";

import {
  type ExecuteState,
  type ExecutionConfig,
  createExecuteState,
  loadExecuteState,
  saveState,
  syncExecuteTasksFromFile,
  getExecuteProgress,
  printExecuteProgress,
  appendProgress,
  incrementSession,
  getNextPendingTask,
  saveExecuteTasks,
  addRecentSummary,
  getPlanNameFromConfigPath,
  hasExistingState,
  getPlanDir,
} from "../../core/state";
import { createExecutePermissionCallback } from "./permissions";
import { loadAndRenderPrompt, type PromptContext } from "../../core/prompts";
import {
  runLongRunningAgent,
  printLongRunningHeader,
  printLongRunningCompletion,
} from "../../core/longrunning";
import {
  runTestSubagent,
  loadTestInfo,
  type TestInfo,
} from "../test";
import {
  runValidationWithFix,
  type ValidationResult,
} from "../validate";
import {
  runVerification,
  MAX_RETRY_ATTEMPTS,
} from "../verify";

const __dirname = dirname(fileURLToPath(import.meta.url));
const PROMPTS_DIR = resolve(__dirname, "prompts");

// =============================================================================
// Types
// =============================================================================

export interface ExecuteOptions {
  configFile: string;
  model?: string;
  maxSessions?: number;
  resume?: boolean;
  force?: boolean;
  tdd?: boolean; // Enable TDD mode with test subagent
}

// =============================================================================
// Health Check
// =============================================================================

export interface HealthCheckResult {
  passed: boolean;
  output: string;
  command?: string;
  exitCode?: number;
}

/**
 * Run a health check command before starting a session.
 * This catches regressions early and provides context for the agent.
 */
async function runHealthCheck(
  command: string | undefined,
  projectDir: string
): Promise<HealthCheckResult> {
  if (!command) {
    return { passed: true, output: "No health check command configured" };
  }

  return new Promise((resolve) => {
    const child = spawn("sh", ["-c", command], {
      cwd: projectDir,
      env: process.env,
      stdio: ["ignore", "pipe", "pipe"],
    });

    let stdout = "";
    let stderr = "";

    child.stdout?.on("data", (data) => {
      stdout += data.toString();
    });

    child.stderr?.on("data", (data) => {
      stderr += data.toString();
    });

    child.on("close", (exitCode) => {
      const output = stdout + (stderr ? `\nSTDERR:\n${stderr}` : "");
      resolve({
        passed: exitCode === 0,
        output: output.slice(-2000), // Limit output size
        command,
        exitCode: exitCode ?? 1,
      });
    });

    child.on("error", (err) => {
      resolve({
        passed: false,
        output: `Failed to run health check: ${err.message}`,
        command,
        exitCode: 1,
      });
    });

    // Timeout after 60 seconds
    setTimeout(() => {
      child.kill();
      resolve({
        passed: false,
        output: "Health check timed out after 60 seconds",
        command,
        exitCode: 124,
      });
    }, 60000);
  });
}

/**
 * Run a verification command to detect task completion.
 * Returns true if the command exits with code 0.
 */
export async function runVerificationCommand(
  command: string,
  projectDir: string
): Promise<{ passed: boolean; output: string; exitCode: number }> {
  return new Promise((resolve) => {
    const child = spawn("sh", ["-c", command], {
      cwd: projectDir,
      env: process.env,
      stdio: ["ignore", "pipe", "pipe"],
    });

    let stdout = "";
    let stderr = "";

    child.stdout?.on("data", (data) => {
      stdout += data.toString();
    });

    child.stderr?.on("data", (data) => {
      stderr += data.toString();
    });

    child.on("close", (exitCode) => {
      const output = stdout + (stderr ? `\nSTDERR:\n${stderr}` : "");
      resolve({
        passed: exitCode === 0,
        output: output.slice(-4000), // Limit output size
        exitCode: exitCode ?? 1,
      });
    });

    child.on("error", (err) => {
      resolve({
        passed: false,
        output: `Failed to run verification: ${err.message}`,
        exitCode: 1,
      });
    });

    // Timeout after 120 seconds
    setTimeout(() => {
      child.kill();
      resolve({
        passed: false,
        output: "Verification command timed out after 120 seconds",
        exitCode: 124,
      });
    }, 120000);
  });
}

// =============================================================================
// System Prompt
// =============================================================================

const SYSTEM_PROMPT = `You are an expert software engineer executing a pre-planned implementation.

You work methodically, one task at a time, following the plan precisely while adapting to discoveries.

You understand that:
- The plan provides the overall vision and approach
- Each task should be completed fully before moving on
- Each session is independent - you have no memory of previous sessions
- Git history and progress.txt show what was done before
- The harness automatically tracks task completion via verification commands
- Your job is to implement and verify, not to track progress

You always:
- Read the plan to understand the big picture
- Check git log and progress.txt for context from previous sessions
- Implement tasks following the plan's approach
- Run verification commands to confirm your work
- Commit progress with descriptive messages
- Document your work in progress.txt

You never:
- Deviate significantly from the plan without good reason
- Try to complete multiple tasks at once without verification
- Skip running verification commands
- Leave the codebase in a broken state

When you complete a task:
- Run the verification command (if provided)
- Commit your changes
- Document in progress.txt
- The harness will detect completion and assign the next task`;

// =============================================================================
// Prompt Context
// =============================================================================

interface ExecutePromptContext extends PromptContext {
  project_dir: string;
  plan_dir: string; // Plan-scoped directory (e.g., .mizu/my-plan/)
  model: string;
  session_number: number;
  plan_file: string;
  plan_content: string;
  total_tasks: number;
  completed_tasks: number;
  remaining_tasks: number;
  percentage: number;
  recent_summaries: string;
  current_task?: string;
  current_task_id?: string;
  current_task_verification?: string;
  // Health check results
  health_check_passed?: boolean;
  health_check_output?: string;
  // TDD test info (from test subagent) - serialized as strings
  test_info_exists?: boolean;
  test_info_test_command?: string;
  test_info_failure_output?: string;
  test_info_status?: string;
}

// =============================================================================
// Prompt Generation
// =============================================================================

function getWorkerPrompt(
  state: ExecuteState,
  healthCheckResult?: HealthCheckResult,
  testInfo?: TestInfo
): string {
  const progress = getExecuteProgress(state.tasks);
  const nextTask = getNextPendingTask(state.tasks);

  // Build recent summaries section
  let recentSummariesText = "No previous sessions yet.";
  if (state.recentSummaries.length > 0) {
    recentSummariesText = state.recentSummaries
      .map((summary, i) => `Session ${state.sessionCount - state.recentSummaries.length + i + 1}:\n${summary}`)
      .join("\n\n");
  }

  // Get relative plan directory path (e.g., .mizu/my-plan)
  const planDir = `.mizu/${state.planName}`;

  const context: ExecutePromptContext = {
    project_dir: state.projectDir,
    plan_dir: planDir,
    model: state.model,
    session_number: state.sessionCount + 1,
    plan_file: state.planFile,
    plan_content: state.planContent,
    total_tasks: progress.total,
    completed_tasks: progress.completed,
    remaining_tasks: progress.pending + progress.blocked,
    percentage: progress.percentage,
    recent_summaries: recentSummariesText,
    current_task: nextTask?.description,
    current_task_id: nextTask?.id,
    current_task_verification: nextTask?.verificationCommand,
    // Health check results
    health_check_passed: healthCheckResult?.passed,
    health_check_output: healthCheckResult && !healthCheckResult.passed
      ? healthCheckResult.output
      : undefined,
    // TDD test info - serialized
    test_info_exists: testInfo !== undefined,
    test_info_test_command: testInfo?.testCommand,
    test_info_failure_output: testInfo?.failureOutput,
    test_info_status: testInfo?.status,
  };

  const promptFile = resolve(PROMPTS_DIR, "worker.md");
  if (existsSync(promptFile)) {
    return loadAndRenderPrompt(promptFile, context);
  }

  // Fallback prompt
  return getFallbackWorkerPrompt(context);
}

// =============================================================================
// Fallback Prompt
// =============================================================================

function getFallbackWorkerPrompt(context: ExecutePromptContext): string {
  const healthCheckSection = context.health_check_output
    ? `\n## ⚠️ Health Check Failed

The health check detected issues:

\`\`\`
${context.health_check_output}
\`\`\`

**Action Required:** Fix these issues before proceeding with new work.\n`
    : "";

  return `# Plan Execution - Session ${context.session_number}

Execute the next task from the plan in ${context.project_dir}.

## Progress
- Tasks: ${context.completed_tasks}/${context.total_tasks} completed (${context.percentage}%)
- Remaining: ${context.remaining_tasks}
${healthCheckSection}
## The Plan

\`\`\`markdown
${context.plan_content}
\`\`\`

## Recent Session Summaries

${context.recent_summaries}

Full history available in: ${context.plan_dir}/progress.txt

## Current Task

${context.current_task ? `**Task ID:** ${context.current_task_id}
**Description:** ${context.current_task}
${context.current_task_verification ? `**Verification:** \`${context.current_task_verification}\`` : "**Verification:** Self-verify and document in completion notes"}` : "No pending tasks - all tasks may be complete!"}

## Workflow

1. **Orient Yourself**
\`\`\`bash
pwd
git log --oneline -10
cat ${context.plan_dir}/progress.txt | tail -50
\`\`\`

2. **Review Current State**
   Check git history and progress notes. Your current task is shown above.

3. **Execute the Task**
   - Follow the plan's approach
   - Be thorough but focused
   - Keep changes aligned with the plan

4. **Verify the Task**
   Run the verification command (if provided):
\`\`\`bash
${context.current_task_verification || "# No automatic verification - manually verify and document"}
\`\`\`

5. **Commit Progress**
\`\`\`bash
git add -A
git commit -m "execute: ${context.current_task_id || "task-XXX"} - <brief description>"
\`\`\`

6. **Document in Progress File**
   Append to ${context.plan_dir}/progress.txt what you accomplished.

## Important

- **One task per session** - Focus on the current task fully
- **Verify before committing** - Run the verification command
- **Leave code working** - Every session should end with a functional codebase
- **Harness tracks progress** - You don't need to update task files; the harness detects completion

Work on ONE task at a time. The harness will automatically detect completion and assign the next task.`;
}

// =============================================================================
// Config Loading
// =============================================================================

function loadExecutionConfig(configFile: string): ExecutionConfig {
  if (!existsSync(configFile)) {
    throw new Error(`Execution config not found: ${configFile}`);
  }

  const content = readFileSync(configFile, "utf-8");
  return JSON.parse(content) as ExecutionConfig;
}

function loadPlanContent(configDir: string, planFile: string): string {
  const planPath = resolve(configDir, planFile);
  if (!existsSync(planPath)) {
    throw new Error(`Plan file not found: ${planPath}`);
  }
  return readFileSync(planPath, "utf-8");
}

// =============================================================================
// State Management
// =============================================================================

function loadOrCreateState(options: ExecuteOptions): ExecuteState {
  const configFile = resolve(options.configFile);
  const config = loadExecutionConfig(configFile);
  const configDir = dirname(configFile);
  const projectDir = resolve(config.projectDir);

  // Derive plan name from config file path
  // Config is at .mizu/<plan-name>/execution.json
  const planName = getPlanNameFromConfigPath(configFile);

  // Try to load existing state
  const existing = loadExecuteState(projectDir, planName);
  if (existing) {
    // Sync tasks from file (agent may have modified it)
    return syncExecuteTasksFromFile(existing);
  }

  // Load plan content
  const planContent = loadPlanContent(configDir, config.planFile);

  // Create new state from config
  return createExecuteState({
    planName,
    projectDir,
    model: options.model ?? config.model ?? "claude-sonnet-4-5",
    configFile,
    planFile: config.planFile,
    planContent,
    tasks: config.tasks,
    permissions: config.permissions,
  });
}

// =============================================================================
// Summary Extraction
// =============================================================================

function extractSessionSummary(response: string, taskId: string | undefined): string {
  // Try to extract a meaningful summary from the response
  // Look for common patterns in completion messages
  const lines = response.split("\n");
  const summaryLines: string[] = [];

  // Look for lines that describe what was done
  for (const line of lines) {
    const lower = line.toLowerCase();
    if (
      lower.includes("completed") ||
      lower.includes("implemented") ||
      lower.includes("added") ||
      lower.includes("created") ||
      lower.includes("fixed") ||
      lower.includes("updated") ||
      lower.includes("commit")
    ) {
      summaryLines.push(line.trim());
      if (summaryLines.length >= 3) break;
    }
  }

  if (summaryLines.length > 0) {
    return `Task ${taskId || "unknown"}: ${summaryLines.join("; ")}`;
  }

  return `Task ${taskId || "unknown"}: Completed`;
}

// =============================================================================
// Main Entry Point
// =============================================================================

export async function runExecute(options: ExecuteOptions): Promise<void> {
  const configFile = resolve(options.configFile);
  const config = loadExecutionConfig(configFile);
  const projectDir = resolve(config.projectDir);
  const model = options.model ?? config.model ?? "claude-sonnet-4-5";

  // Derive plan name from config file path
  const planName = getPlanNameFromConfigPath(configFile);
  const planDir = getPlanDir(projectDir, planName);

  // Check for existing state in plan-scoped directory
  const stateExists = hasExistingState(projectDir, planName);

  if (stateExists && !options.resume && !options.force) {
    console.error("\nError: Execution state already exists for this plan.");
    console.error(`Plan directory: ${planDir}`);
    console.error("Use --resume to continue from where you left off.");
    console.error("Use --force to start fresh (will overwrite existing progress).\n");
    process.exit(1);
  }

  if (stateExists && options.force) {
    // Delete existing state files in plan directory
    const { unlinkSync } = await import("node:fs");
    const stateFile = resolve(planDir, "state.json");
    const tasksFile = resolve(planDir, "tasks.json");
    const progressFile = resolve(planDir, "progress.txt");

    if (existsSync(stateFile)) unlinkSync(stateFile);
    if (existsSync(tasksFile)) unlinkSync(tasksFile);
    if (existsSync(progressFile)) unlinkSync(progressFile);

    console.log("Existing state cleared. Starting fresh.\n");
  }

  // Ensure project directory exists
  if (!existsSync(projectDir)) {
    mkdirSync(projectDir, { recursive: true });
  }

  // Load or create state
  let state = loadOrCreateState({ ...options, configFile });

  // Save tasks file for agent to work with
  saveExecuteTasks(state.projectDir, state.planName, state.tasks);

  // Print header
  printLongRunningHeader({
    agentName: "Plan Execution Agent",
    projectDir,
    model,
    stateType: "execute",
    initialized: state.initialized,
    sessionCount: state.sessionCount,
    maxSessions: options.maxSessions,
  });

  // Print plan info
  console.log(`Plan: ${state.planName}`);
  console.log(`Plan directory: .mizu/${state.planName}/`);
  console.log(`Config file: ${configFile}\n`);

  printExecuteProgress(state);

  // Track current task, health check results, and test info for the current session
  let currentTaskId: string | undefined;
  let currentTask: ReturnType<typeof getNextPendingTask>;
  let lastHealthCheckResult: HealthCheckResult | undefined;
  let currentTestInfo: TestInfo | undefined;

  // Determine health check command (use first task's verification or a common pattern)
  const healthCheckCommand = config.healthCheckCommand ??
    state.tasks.find(t => t.verificationCommand)?.verificationCommand;

  // TDD mode flag
  const tddEnabled = options.tdd ?? config.tdd ?? false;
  if (tddEnabled) {
    console.log("TDD mode enabled: Test subagent will run before each task.\n");
  }

  // Run the long-running agent loop
  const result = await runLongRunningAgent({
    projectDir,
    model,
    agentType: "execute",
    systemPrompt: SYSTEM_PROMPT,
    maxSessions: options.maxSessions ?? Infinity,
    enablePuppeteer: false,
    sandboxEnabled: true,
    canUseTool: createExecutePermissionCallback(state.permissions),

    getPrompt: (sessionNumber, currentState) => {
      const executeState = currentState as ExecuteState;
      currentTask = getNextPendingTask(executeState.tasks);
      currentTaskId = currentTask?.id;
      return getWorkerPrompt(executeState, lastHealthCheckResult, currentTestInfo);
    },

    loadState: () => loadOrCreateState({ ...options, configFile }),

    saveState: (updatedState) => {
      state = updatedState as ExecuteState;
      saveState(state);
    },

    onSessionStart: async (sessionNumber) => {
      console.log(`\n--- Plan Execution Session ${sessionNumber} ---\n`);

      // Get the current task for this session
      const nextTask = getNextPendingTask(state.tasks);

      // Run health check before session
      if (healthCheckCommand) {
        console.log(`Running health check: ${healthCheckCommand}`);
        lastHealthCheckResult = await runHealthCheck(healthCheckCommand, projectDir);
        if (lastHealthCheckResult.passed) {
          console.log("✓ Health check passed\n");
        } else {
          console.log(`⚠ Health check failed (exit code ${lastHealthCheckResult.exitCode})`);
          console.log("Agent will be informed of failures.\n");
        }
      }

      // Run test subagent in TDD mode (before main agent)
      if (tddEnabled && nextTask) {
        // Check if tests already exist for this task
        currentTestInfo = loadTestInfo(projectDir, state.planName, nextTask.id) ?? undefined;

        if (!currentTestInfo || currentTestInfo.status !== "red") {
          console.log(`\n=== TDD: Running Test Subagent for ${nextTask.id} ===\n`);
          const testResult = await runTestSubagent(nextTask, state, model);

          if (testResult.status === "red") {
            console.log("\n✓ Test subagent completed: Tests are RED (failing)\n");
            currentTestInfo = loadTestInfo(projectDir, state.planName, nextTask.id) ?? undefined;
          } else if (testResult.status === "green") {
            console.log("\n⚠ Tests passed unexpectedly. Feature may already exist.\n");
          } else {
            console.log(`\n⚠ Test subagent error: ${testResult.error}\n`);
          }
        } else {
          console.log(`\n✓ Tests already exist and are RED for ${nextTask.id}\n`);
        }

        // Run test validation to check tests are valid (no bugs in tests themselves)
        // Uses self-fix to automatically repair common test bugs
        if (currentTestInfo?.status === "red") {
          console.log(`\n=== TDD: Validating Tests for ${nextTask.id} ===\n`);
          const validationResult = await runValidationWithFix(nextTask, state, currentTestInfo, model);

          if (validationResult.valid) {
            if (validationResult.fixApplied) {
              console.log("✓ Tests validated (after automatic fix) - ready for implementation\n");
            } else {
              console.log("✓ Tests validated - ready for implementation\n");
            }
          } else {
            console.log("⚠ Test validation issues detected:\n");
            for (const issue of validationResult.issues.slice(0, 3)) {
              console.log(`  - [${issue.type}] ${issue.message}`);
              if (issue.suggestion) {
                console.log(`    Suggestion: ${issue.suggestion}`);
              }
            }
            console.log("\nMain agent will be informed of these issues.\n");
          }
        }
      }
    },

    onSessionEnd: async (sessionNumber, response) => {
      // Extract summary for bounded context
      const summary = extractSessionSummary(response, currentTaskId);

      // Get current attempt count for this task
      const taskIndex = state.tasks.findIndex(t => t.id === currentTaskId);
      const currentAttemptCount = taskIndex >= 0
        ? (state.tasks[taskIndex].attemptCount ?? 0) + 1
        : 1;

      // Run verification (use full verification subagent in TDD mode)
      if (tddEnabled && currentTask) {
        // Full TDD verification with retry support
        const verifyResult = await runVerification(currentTask, state, currentAttemptCount);

        if (verifyResult.passed) {
          console.log("✓ Verification PASSED - marking task complete\n");
          if (taskIndex >= 0) {
            state.tasks[taskIndex].status = "completed";
            state.tasks[taskIndex].completedAt = new Date().toISOString();
            state.tasks[taskIndex].attemptCount = currentAttemptCount;
          }
        } else {
          // Check if we've hit max retries
          if (currentAttemptCount >= MAX_RETRY_ATTEMPTS) {
            console.log(`\n⚠ Max retries (${MAX_RETRY_ATTEMPTS}) exceeded - marking task BLOCKED\n`);
            if (taskIndex >= 0) {
              state.tasks[taskIndex].status = "blocked";
              state.tasks[taskIndex].attemptCount = currentAttemptCount;
              state.tasks[taskIndex].notes = `Blocked after ${MAX_RETRY_ATTEMPTS} failed attempts. ${verifyResult.retryGuidance || ""}`;
            }
          } else {
            console.log(`\n✗ Verification FAILED (attempt ${currentAttemptCount}/${MAX_RETRY_ATTEMPTS})`);
            console.log("Task will be retried in next session.\n");
            if (taskIndex >= 0) {
              state.tasks[taskIndex].attemptCount = currentAttemptCount;
              state.tasks[taskIndex].notes = verifyResult.retryGuidance;
            }
          }
        }
      } else if (currentTask?.verificationCommand) {
        // Simple verification (non-TDD mode)
        console.log(`\nRunning verification: ${currentTask.verificationCommand}`);
        const verifyResult = await runVerificationCommand(
          currentTask.verificationCommand,
          projectDir
        );

        if (verifyResult.passed) {
          console.log("✓ Verification passed - marking task complete\n");
          if (taskIndex >= 0) {
            state.tasks[taskIndex].status = "completed";
            state.tasks[taskIndex].completedAt = new Date().toISOString();
            state.tasks[taskIndex].verificationOutput = verifyResult.output;
          }
        } else {
          console.log(`✗ Verification failed (exit code ${verifyResult.exitCode})`);

          // Check for max retries in non-TDD mode too
          if (currentAttemptCount >= MAX_RETRY_ATTEMPTS) {
            console.log(`\n⚠ Max retries (${MAX_RETRY_ATTEMPTS}) exceeded - marking task BLOCKED\n`);
            if (taskIndex >= 0) {
              state.tasks[taskIndex].status = "blocked";
              state.tasks[taskIndex].attemptCount = currentAttemptCount;
              state.tasks[taskIndex].verificationOutput = verifyResult.output;
            }
          } else {
            console.log(`Task remains in progress for next session (attempt ${currentAttemptCount}/${MAX_RETRY_ATTEMPTS}).\n`);
            if (taskIndex >= 0) {
              state.tasks[taskIndex].attemptCount = currentAttemptCount;
              state.tasks[taskIndex].verificationOutput = verifyResult.output;
            }
          }
        }
      } else {
        // No verification command - trust the agent (legacy behavior)
        console.log("\nNo verification command for this task.\n");
      }

      // Increment session and add summary
      state = incrementSession(state) as ExecuteState;
      state = addRecentSummary(state, summary);

      saveState(state);
      saveExecuteTasks(state.projectDir, state.planName, state.tasks);

      // Append to progress
      const progress = getExecuteProgress(state.tasks);
      appendProgress(
        projectDir,
        state.planName,
        `Session ${sessionNumber} completed. Tasks: ${progress.completed}/${progress.total} completed.\n${summary}`
      );
    },

    isComplete: (_response) => {
      // Harness-driven completion: check if all tasks are complete
      // (verification commands determine completion, not agent's claims)
      const progress = getExecuteProgress(state.tasks);
      return progress.completed === progress.total && progress.total > 0;
    },
  });

  // Print completion summary
  printLongRunningCompletion({
    agentName: "Plan Execution Agent",
    completed: result.completed,
    sessions: result.sessions,
    state,
  });
}

// =============================================================================
// Exports
// =============================================================================

export { getWorkerPrompt };
