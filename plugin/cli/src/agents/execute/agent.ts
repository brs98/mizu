/**
 * Execute Agent
 *
 * Executes plans generated by Claude Code's plan mode via the /harness skill.
 * Unlike other agents, this one skips the initializer phase - tasks come from
 * the pre-generated execution config.
 *
 * Key differences from other agents:
 * - No initializer phase (tasks are pre-defined in config)
 * - Bounded summary system (last 3 summaries + stats in prompt)
 * - Full plan context in every worker prompt
 */

import { readFileSync, existsSync, mkdirSync } from "node:fs";
import { resolve, dirname } from "node:path";
import { fileURLToPath } from "node:url";

import {
  type ExecuteState,
  type ExecutionConfig,
  createExecuteState,
  loadExecuteState,
  saveState,
  syncExecuteTasksFromFile,
  getExecuteProgress,
  isComplete,
  printExecuteProgress,
  appendProgress,
  incrementSession,
  getNextPendingTask,
  saveExecuteTasks,
  addRecentSummary,
  getPlanNameFromConfigPath,
  hasExistingState,
  getPlanDir,
} from "../../core/state";
import { createExecutePermissionCallback } from "./permissions";
import { loadAndRenderPrompt, type PromptContext } from "../../core/prompts";
import {
  runLongRunningAgent,
  printLongRunningHeader,
  printLongRunningCompletion,
} from "../../core/longrunning";

const __dirname = dirname(fileURLToPath(import.meta.url));
const PROMPTS_DIR = resolve(__dirname, "prompts");

// =============================================================================
// Types
// =============================================================================

export interface ExecuteOptions {
  configFile: string;
  model?: string;
  maxSessions?: number;
  resume?: boolean;
  force?: boolean;
}

// =============================================================================
// System Prompt
// =============================================================================

const SYSTEM_PROMPT = `You are an expert software engineer executing a pre-planned implementation.

You work methodically, one task at a time, following the plan precisely while adapting to discoveries.

You understand that:
- The plan provides the overall vision and approach
- Each task should be completed fully before moving on
- Each session is independent - you have no memory of previous sessions
- .mizu/<plan-name>/tasks.json is the source of truth for task progress
- Git history and .mizu/<plan-name>/progress.txt show what was done before
- Verification proves tasks are actually complete

You always:
- Read the plan to understand the big picture
- Read tasks.json to find the next pending task
- Check git log and progress.txt for context from previous sessions
- Implement tasks following the plan's approach
- Verify your work before marking tasks complete
- Commit progress with descriptive messages
- Update tasks.json and progress.txt before ending

You never:
- Deviate significantly from the plan without good reason
- Try to complete multiple tasks at once without verification
- Mark tasks as completed without running verification
- Leave the codebase in a broken state

When all tasks are complete:
- All tasks in tasks.json should be marked "completed"
- Tests should pass (if applicable)
- Say "Plan execution complete" to indicate completion`;

// =============================================================================
// Prompt Context
// =============================================================================

interface ExecutePromptContext extends PromptContext {
  project_dir: string;
  plan_dir: string; // Plan-scoped directory (e.g., .mizu/my-plan/)
  model: string;
  session_number: number;
  plan_file: string;
  plan_content: string;
  total_tasks: number;
  completed_tasks: number;
  remaining_tasks: number;
  percentage: number;
  recent_summaries: string;
  current_task?: string;
  current_task_id?: string;
  current_task_verification?: string;
}

// =============================================================================
// Prompt Generation
// =============================================================================

function getWorkerPrompt(state: ExecuteState): string {
  const progress = getExecuteProgress(state.tasks);
  const nextTask = getNextPendingTask(state.tasks);

  // Build recent summaries section
  let recentSummariesText = "No previous sessions yet.";
  if (state.recentSummaries.length > 0) {
    recentSummariesText = state.recentSummaries
      .map((summary, i) => `Session ${state.sessionCount - state.recentSummaries.length + i + 1}:\n${summary}`)
      .join("\n\n");
  }

  // Get relative plan directory path (e.g., .mizu/my-plan)
  const planDir = `.mizu/${state.planName}`;

  const context: ExecutePromptContext = {
    project_dir: state.projectDir,
    plan_dir: planDir,
    model: state.model,
    session_number: state.sessionCount + 1,
    plan_file: state.planFile,
    plan_content: state.planContent,
    total_tasks: progress.total,
    completed_tasks: progress.completed,
    remaining_tasks: progress.pending + progress.blocked,
    percentage: progress.percentage,
    recent_summaries: recentSummariesText,
    current_task: nextTask?.description,
    current_task_id: nextTask?.id,
    current_task_verification: nextTask?.verificationCommand,
  };

  const promptFile = resolve(PROMPTS_DIR, "worker.md");
  if (existsSync(promptFile)) {
    return loadAndRenderPrompt(promptFile, context);
  }

  // Fallback prompt
  return getFallbackWorkerPrompt(context);
}

// =============================================================================
// Fallback Prompt
// =============================================================================

function getFallbackWorkerPrompt(context: ExecutePromptContext): string {
  return `# Plan Execution - Session ${context.session_number}

Execute the next task from the plan in ${context.project_dir}.

## Plan Directory

All execution artifacts are in: ${context.plan_dir}/

## Progress
- Tasks: ${context.completed_tasks}/${context.total_tasks} completed (${context.percentage}%)
- Remaining: ${context.remaining_tasks}

## The Plan

\`\`\`markdown
${context.plan_content}
\`\`\`

## Recent Session Summaries

${context.recent_summaries}

Full history available in: ${context.plan_dir}/progress.txt

## Current Task

${context.current_task ? `**Task ID:** ${context.current_task_id}
**Description:** ${context.current_task}
${context.current_task_verification ? `**Verification:** \`${context.current_task_verification}\`` : "**Verification:** Self-verify and document in completion notes"}` : "No pending tasks - all tasks may be complete!"}

## Your Tasks

1. **Get Your Bearings**
\`\`\`bash
pwd
git log --oneline -10
cat ${context.plan_dir}/progress.txt | tail -50
\`\`\`

2. **Read ${context.plan_dir}/tasks.json**
   Confirm the current task and check dependencies.

3. **Execute the Task**
   - Follow the plan's approach
   - Be thorough but focused
   - Keep changes aligned with the plan

4. **Verify the Task**
   Run the verification command (if provided):
\`\`\`bash
${context.current_task_verification || "# No automatic verification - manually verify and document"}
\`\`\`

5. **Update ${context.plan_dir}/tasks.json**
   Mark the task as completed:
\`\`\`json
{
  "id": "${context.current_task_id || "task-XXX"}",
  "status": "completed",
  "completedAt": "${new Date().toISOString()}"
}
\`\`\`

6. **Commit Progress**
\`\`\`bash
git add -A
git commit -m "execute: complete ${context.current_task_id || "task-XXX"} - <brief description>"
\`\`\`

7. **Update ${context.plan_dir}/progress.txt**
   Document what you accomplished in this session.

## Completion

When ALL tasks are completed and verified:
- Say "Plan execution complete" to indicate completion

Work on ONE task at a time. Leave the codebase in a working state.`;
}

// =============================================================================
// Config Loading
// =============================================================================

function loadExecutionConfig(configFile: string): ExecutionConfig {
  if (!existsSync(configFile)) {
    throw new Error(`Execution config not found: ${configFile}`);
  }

  const content = readFileSync(configFile, "utf-8");
  return JSON.parse(content) as ExecutionConfig;
}

function loadPlanContent(configDir: string, planFile: string): string {
  const planPath = resolve(configDir, planFile);
  if (!existsSync(planPath)) {
    throw new Error(`Plan file not found: ${planPath}`);
  }
  return readFileSync(planPath, "utf-8");
}

// =============================================================================
// State Management
// =============================================================================

function loadOrCreateState(options: ExecuteOptions): ExecuteState {
  const configFile = resolve(options.configFile);
  const config = loadExecutionConfig(configFile);
  const configDir = dirname(configFile);
  const projectDir = resolve(config.projectDir);

  // Derive plan name from config file path
  // Config is at .mizu/<plan-name>/execution.json
  const planName = getPlanNameFromConfigPath(configFile);

  // Try to load existing state
  const existing = loadExecuteState(projectDir, planName);
  if (existing) {
    // Sync tasks from file (agent may have modified it)
    return syncExecuteTasksFromFile(existing);
  }

  // Load plan content
  const planContent = loadPlanContent(configDir, config.planFile);

  // Create new state from config
  return createExecuteState({
    planName,
    projectDir,
    model: options.model ?? config.model ?? "claude-sonnet-4-5",
    configFile,
    planFile: config.planFile,
    planContent,
    tasks: config.tasks,
    permissions: config.permissions,
  });
}

// =============================================================================
// Completion Detection
// =============================================================================

function checkExecuteCompletion(response: string, state: ExecuteState): boolean {
  // Re-sync tasks from file after each session
  const updated = syncExecuteTasksFromFile(state);

  // Check if all tasks are complete
  if (isComplete(updated)) {
    return true;
  }

  // Also check for explicit completion phrases (fallback)
  const lower = response.toLowerCase();
  const completionPhrases = [
    "plan execution complete",
    "all tasks completed",
    "execution complete",
    "plan complete",
  ];

  return completionPhrases.some((phrase) => lower.includes(phrase));
}

// =============================================================================
// Summary Extraction
// =============================================================================

function extractSessionSummary(response: string, taskId: string | undefined): string {
  // Try to extract a meaningful summary from the response
  // Look for common patterns in completion messages
  const lines = response.split("\n");
  const summaryLines: string[] = [];

  // Look for lines that describe what was done
  for (const line of lines) {
    const lower = line.toLowerCase();
    if (
      lower.includes("completed") ||
      lower.includes("implemented") ||
      lower.includes("added") ||
      lower.includes("created") ||
      lower.includes("fixed") ||
      lower.includes("updated") ||
      lower.includes("commit")
    ) {
      summaryLines.push(line.trim());
      if (summaryLines.length >= 3) break;
    }
  }

  if (summaryLines.length > 0) {
    return `Task ${taskId || "unknown"}: ${summaryLines.join("; ")}`;
  }

  return `Task ${taskId || "unknown"}: Completed`;
}

// =============================================================================
// Main Entry Point
// =============================================================================

export async function runExecute(options: ExecuteOptions): Promise<void> {
  const configFile = resolve(options.configFile);
  const config = loadExecutionConfig(configFile);
  const projectDir = resolve(config.projectDir);
  const model = options.model ?? config.model ?? "claude-sonnet-4-5";

  // Derive plan name from config file path
  const planName = getPlanNameFromConfigPath(configFile);
  const planDir = getPlanDir(projectDir, planName);

  // Check for existing state in plan-scoped directory
  const stateExists = hasExistingState(projectDir, planName);

  if (stateExists && !options.resume && !options.force) {
    console.error("\nError: Execution state already exists for this plan.");
    console.error(`Plan directory: ${planDir}`);
    console.error("Use --resume to continue from where you left off.");
    console.error("Use --force to start fresh (will overwrite existing progress).\n");
    process.exit(1);
  }

  if (stateExists && options.force) {
    // Delete existing state files in plan directory
    const { unlinkSync } = await import("node:fs");
    const stateFile = resolve(planDir, "state.json");
    const tasksFile = resolve(planDir, "tasks.json");
    const progressFile = resolve(planDir, "progress.txt");

    if (existsSync(stateFile)) unlinkSync(stateFile);
    if (existsSync(tasksFile)) unlinkSync(tasksFile);
    if (existsSync(progressFile)) unlinkSync(progressFile);

    console.log("Existing state cleared. Starting fresh.\n");
  }

  // Ensure project directory exists
  if (!existsSync(projectDir)) {
    mkdirSync(projectDir, { recursive: true });
  }

  // Load or create state
  let state = loadOrCreateState({ ...options, configFile });

  // Save tasks file for agent to work with
  saveExecuteTasks(state.projectDir, state.planName, state.tasks);

  // Print header
  printLongRunningHeader({
    agentName: "Plan Execution Agent",
    projectDir,
    model,
    stateType: "execute",
    initialized: state.initialized,
    sessionCount: state.sessionCount,
    maxSessions: options.maxSessions,
  });

  // Print plan info
  console.log(`Plan: ${state.planName}`);
  console.log(`Plan directory: .mizu/${state.planName}/`);
  console.log(`Config file: ${configFile}\n`);

  printExecuteProgress(state);

  // Track current task for summary extraction
  let currentTaskId: string | undefined;

  // Run the long-running agent loop
  const result = await runLongRunningAgent({
    projectDir,
    model,
    agentType: "execute",
    systemPrompt: SYSTEM_PROMPT,
    maxSessions: options.maxSessions ?? Infinity,
    enablePuppeteer: false,
    sandboxEnabled: true,
    canUseTool: createExecutePermissionCallback(state.permissions),

    getPrompt: (sessionNumber, currentState) => {
      const executeState = currentState as ExecuteState;
      const nextTask = getNextPendingTask(executeState.tasks);
      currentTaskId = nextTask?.id;
      return getWorkerPrompt(executeState);
    },

    loadState: () => loadOrCreateState({ ...options, configFile }),

    saveState: (updatedState) => {
      state = updatedState as ExecuteState;
      saveState(state);
    },

    onSessionStart: (sessionNumber) => {
      console.log(`\n--- Plan Execution Session ${sessionNumber} ---\n`);
    },

    onSessionEnd: (sessionNumber, response) => {
      // Sync state from files
      state = syncExecuteTasksFromFile(state);
      state = incrementSession(state) as ExecuteState;

      // Extract and store summary for bounded context
      const summary = extractSessionSummary(response, currentTaskId);
      state = addRecentSummary(state, summary);

      saveState(state);

      // Also save tasks file
      saveExecuteTasks(state.projectDir, state.planName, state.tasks);

      // Append to progress
      const progress = getExecuteProgress(state.tasks);
      appendProgress(
        projectDir,
        state.planName,
        `Session ${sessionNumber} completed. Tasks: ${progress.completed}/${progress.total} completed.\n${summary}`
      );
    },

    isComplete: (response) => checkExecuteCompletion(response, state),
  });

  // Print completion summary
  printLongRunningCompletion({
    agentName: "Plan Execution Agent",
    completed: result.completed,
    sessions: result.sessions,
    state,
  });
}

// =============================================================================
// Exports
// =============================================================================

export { getWorkerPrompt };
